# piggybacking off mlaventure's emacs config redo
# https://github.com/mlaventure/emacs-config/blob/master/.emacs.d/config.org
* Packages
This section has to be first, otherwise required packages won't be
able to be installed and loaded

- Who doesn't like a package manager? Noone, so always load it up.
  #+BEGIN_SRC emacs-lisp
    (require 'package)
    (add-to-list 'package-archives
                 '("melpa" . "http://melpa.milkbox.net/packages/") t)
  #+END_SRC
- We want to be able to setup those package early, so initialize them
  all
  #+BEGIN_SRC emacs-lisp
  ;;  (package-initialize)
  #+END_SRC
- Refresh the package list content if if doesn't exist yet (so only
  done the first time this configuration is loaded). We don't want to
  do it at every start, it would slow us down too much
  #+BEGIN_SRC emacs-lisp
    (unless package-archive-contents
      (package-refresh-contents))
  #+END_SRC
- Here we define a handy helper that will install a package if it's
  not yet present then require it
  #+BEGIN_SRC emacs-lisp
    (defun activate-package (pkg)
      "Install a package if it is not present then require it"
      (unless (package-installed-p pkg)
        (package-install pkg))
      (require pkg))
  #+END_SRC
- Let's try and make use of [[https://github.com/jwiegley/use-package][use-package]]. And set it to always install
  packages if they're not present.
  #+BEGIN_SRC emacs-lisp
    (activate-package 'use-package)
    (setq use-package-always-ensure t)
  #+END_SRC
- Use auto-compile to always get up-to-date compiled packages
  #+BEGIN_SRC emacs-lisp
    (use-package auto-compile
                 :init
                 (setq load-prefer-newer t)
                 :commands (auto-compile-on-load-mode)
                 :config
                 (setq auto-compile-display-buffer nil)
                 (setq auto-compile-mode-line-counter t)
                 (auto-compile-on-load-mode))
                 
  #+END_SRC
* Basic Tooling, General Settings and One Liners
** one-liners
#+BEGIN_SRC emacs-lisp
  (use-package all-the-icons
               :config
               (setq neo-theme (if (display-graphic-p) 'icons 'arrow)))
  (scroll-bar-mode -1)
  (menu-bar-mode -1)
  (tool-bar-mode -1)
  (setq inhibit-startup-screen t)
  ; custom theme
  (load-theme 'icy-hex-gui t)
  ; line numbers
  (global-linum-mode 1)
  (setq column-number-mode t)
  ; Window Movement (Shift+Direction)
  (windmove-default-keybindings)
  (setq windmove-wrap-around t)
  ; Make windmove work in org-mode:
  (add-hook 'org-shiftup-final-hook 'windmove-up)
  (add-hook 'org-shiftleft-final-hook 'windmove-left)
  (add-hook 'org-shiftdown-final-hook 'windmove-down)
  (add-hook 'org-shiftright-final-hook 'windmove-right)
  ; rainbow-delimiters
  (show-paren-mode t)
  (use-package rainbow-delimiters)
  (add-hook 'prog-mode-hook 'rainbow-delimiters-mode)
  ; highlight current line
  (global-hl-line-mode t)
  ; rainbow representations of hex/etc colors
  (add-hook 'less-mode-hook 'rainbow-mode)
  (add-hook 'sass-mode-hook 'rainbow-mode)
  (add-hook 'web-mode-hook 'rainbow-mode)
  ; no tabs (only spaces)
  (setq-default indent-tabs-mode nil)
  ; enforce 80 column rule
  (autoload 'column-enforce-mode "column-enforce-mode" nil t)
  ; use zsh
  (setq shell-file-name "zsh")
  (setq shell-command-switch "-ic")
  ; simpleclip
  (simpleclip-mode 1)
  ; camelCase navigation
  (global-subword-mode t)
  ; Teach emacs to accept =y= and =n= for =yes= and =no=.
  (fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC
** spaceline
   #+BEGIN_SRC emacs-lisp
     (require 'spaceline-config)
     (spaceline-spacemacs-theme)
   #+END_SRC
** Saves
   Make Saves go in another directory
   Make more of them
  #+BEGIN_SRC emacs-lisp
  (setq backup-directory-alist `(("." . "~/.saves")))
  (setq backup-by-copying t)
  (setq delete-old-versions t
    kept-new-versions 6
    kept-old-versions 2
    version-control t)
  #+END_SRC
** YASnippets
  #+BEGIN_SRC emacs-lisp
    (setq yas-snippet-dirs
          '("~/.emacs.d/snippets" ;; personal snippets
           ))
    (yas-global-mode 1)
  #+END_SRC
** KeyFreq
   #+BEGIN_SRC emacs-lisp
     (require 'keyfreq)
     (setq keyfreq-excluded-commands
           '(self-insert-command
             abort-recursive-edit
             previous-line
             next-line))
     (keyfreq-mode 1)
     (keyfreq-autosave-mode 1)
   #+END_SRC
** NeoTree
   #+BEGIN_SRC emacs-lisp
         (use-package neotree
                      :after all-the-icons
                      :init
                      (setq neo-smart-open t)
                      (setq neo-theme (if window-system 'icons 'arrow))
                      (setq projectile-switch-project-action 'neotree-projectile-action)
                      :commands (neotree-toggle)
                      :bind ("<f8>" . neotree-toggle))

   #+END_SRC
** abbrev-mode
   #+BEGIN_SRC emacs-lisp
     (dolist (hook '(markdown-mode-hook
                     text-mode-hook))
       (add-hook hook (lambda () (abbrev-mode 1))))  
   #+END_SRC
** undo-tree
   #+BEGIN_SRC emacs-lisp
     (global-undo-tree-mode)
     (setq undo-tree-visualizer-diff t)
   #+END_
* Visual Regexp
#+BEGIN_SRC emacs-lisp
  (define-key global-map (kbd "C-c r") 'vr/replace)
  (define-key global-map (kbd "C-c q") 'vr/query-replace)

  ;; if you use multiple-cursors, this is for you:
  ;(define-key global-map (kbd "C-c m") 'vr/mc-mark)

  ;; to use visual-regexp-steroids's isearch instead of the built-in regexp isearch, also include the following lines:
  (define-key esc-map (kbd "C-r") 'vr/isearch-backward) ;; C-M-r
  (define-key esc-map (kbd "C-s") 'vr/isearch-forward) ;; C-M-s
#+END_SRC
* Keybindings
*** (C-z) Don't suspend on C-z. I do this too often.
  #+BEGIN_SRC emacs-lisp
  (global-unset-key (kbd "C-z"))
  #+END_SRC
*** Avy (previously Ace-Jump-Mode)
  #+BEGIN_SRC emacs-lisp
    (avy-setup-default)
    (global-set-key (kbd "C-c SPC") 'avy-goto-char)
    (global-set-key (kbd "M-g g") 'avy-goto-line)
    (global-set-key (kbd "M-g e") 'avy-goto-word-0)
    (global-set-key (kbd "M-g w") 'avy-goto-word-1)
  #+END_SRC
*** ace-window
    #+BEGIN_SRC emacs-lisp
      (global-set-key (kbd "C-x o") 'ace-window)
    #+END_SRC
*** (M-x) smex
  #+BEGIN_SRC emacs-lisp
  (autoload 'smex "smex"
    "Smex is a M-x enhancement for Emacs, it provides a convenient interface to your recently and most frequently used commands.")
  (global-set-key (kbd "M-x") 'smex)
  #+END_SRC
* Org-mode
  #+BEGIN_SRC emacs-lisp
    (require 'org)
  #+END_SRC
** org-capture-alfred
#+BEGIN_SRC emacs-lisp
  (defun make-orgcapture-frame ()
    "Create a new frame and run org-capture."
    (interactive)
    (make-frame '((name . "remember") (width . 80) (height . 16)
                  (top . 400) (left . 300)
                  (font . "-apple-Monaco-medium-normal-normal-*-13-*-*-*-m-0-iso10646-1")
                  ))
    (select-frame-by-name "remember")
    (org-capture))
#+END_SRC
** setq
   #+BEGIN_SRC emacs-lisp
     (set 'my-orgdir "~/Dropbox/__notes/_org")
     (setq org-src-fontify-natively t)
     (setq org-agenda-files (list (concat my-orgdir "/personal.org")))
     (setq org-default-notes-file (concat my-orgdir "/notes.org"))
     (define-key global-map "\C-cc" 'org-capture)
     (setq org-capture-templates
           '(("t" "Todo" entry (file+headline (concat my-orgdir "/todo.org") "Tasks")
              "* TODO %?\n  %i\n  %a")
             ("j" "Journal" entry (file+datetree (concat my-orgdir "/journal.org"))
              "* %?\nEntered on %U\n  %i\n  %a")))
   #+END_SRC
** Langs
  #+BEGIN_SRC emacs-lisp
    (org-babel-do-load-languages
     'org-babel-load-languages
     '((dot . t)
       (emacs-lisp . t)
       (awk . t)
       (haskell . t)
       (css . t)
       (js . t)))
  #+END_SRC
** theme
  #+BEGIN_SRC emacs-lisp
    (require 'org-bullets)
    (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1)))
    (setq org-hide-leading-stars t)
    (setq org-ellipsis " \u25bc")
  #+END_SRC
* Flycheck
** boot it
  #+BEGIN_SRC emacs-lisp
    (require 'flycheck)
    (add-hook 'after-init-hook #'global-flycheck-mode)
    ;; turn on flychecking globally
    (add-hook 'after-init-hook #'global-flycheck-mode)

    ;; disable jshint since we prefer eslint checking
    (setq-default flycheck-disabled-checkers
                  (append flycheck-disabled-checkers
                          '(javascript-jshint)))

    ;; use eslint with web-mode for jsx files
    (setq flycheck-checkers '(javascript-eslint))
    (flycheck-add-mode 'javascript-eslint 'web-mode)

    ;; disable json-jsonlist checking for json files
    (setq-default flycheck-disabled-checkers
                  (append flycheck-disabled-checkers
                          '(json-jsonlist)))
  #+END_SRC
* Magit
  #+BEGIN_SRC emacs-lisp
    (global-set-key (kbd "C-x g") 'magit-status)
  #+END_SRC
* LANG
** Haskell
*** Intero
#+BEGIN_SRC emacs-lisp
  (add-hook 'haskell-mode-hook 'intero-mode)
#+END_SRC
*** haskell-mode
#+BEGIN_SRC emacs-lisp

#+END_SRC
*** Graveyard
**** structured-haskell-mode
     #+BEGIN_SRC emacs-lisp
       ;(require 'shm)
       ;(add-hook 'haskell-mode-hook 'structured-haskell-mode)
       ;(setq shm-program-name "structured-haskell-mode")
     #+END_SRC
**** Stylish-Haskell (on-save)
    #+BEGIN_SRC emacs-lisp
      ;(setq haskell-stylish-on-save t)
    #+END_SRC
**** ghc-mod
   #+BEGIN_SRC emacs-lisp
   ;(autoload 'ghc-init "ghc" nil t)
   #+END_SRC
**** Flycheck
#+BEGIN_SRC emacs-lisp
  ;; (defun haskell-mode-setup-hook ()
  ;;   (interactive)
  ;;   (progn
  ;;     ;; ...
  ;;     (flycheck-select-checker 'haskell-stack-ghc)))

  ;; (add-hook 'haskell-mode-hook 'haskell-mode-setup-hook)
#+END_SRC
**** Haskell Mode
***** ghc-init
     #+BEGIN_SRC emacs-lisp
       ;(add-hook 'haskell-mode-hook 'ghc-init)
     #+END_SRC
***** setq
#+BEGIN_SRC emacs-lisp
  ;; (setq
  ;;  ;; Use notify.el (if you have it installed) at the end of running
  ;;  ;; Cabal commands or generally things worth notifying.
  ;;  haskell-notify-p t
  ;;  ;; To enable tags generation on save.
  ;;  haskell-tags-on-save t
  ;;  ;; Remove annoying error popups
  ;;  haskell-interactive-popup-errors nil
  ;;  ;; Better import handling
  ;;  haskell-process-suggest-remove-import-lines t
  ;;  haskell-process-auto-import-loaded-modules t
  ;;  ;; Disable haskell-stylish-on-save, as it breaks flycheck highlighting.
  ;;  ;; NOTE: May not be true anymore - taksuyu 2015-10-06
  ;;  haskell-stylish-on-save nil)

  ;; ;; align rules for Haskell
  ;; (with-eval-after-load 'align
  ;;   (add-to-list 'align-rules-list
  ;;                '(haskell-types
  ;;                  (regexp . "\\(\\s-+\\)\\(::\\|∷\\)\\s-+")
  ;;                  (modes . '(haskell-mode literate-haskell-mode))))
  ;;   (add-to-list 'align-rules-list
  ;;                '(haskell-assignment
  ;;                  (regexp . "\\(\\s-+\\)=\\s-+")
  ;;                  (modes . '(haskell-mode literate-haskell-mode))))
  ;;   (add-to-list 'align-rules-list
  ;;                '(haskell-arrows
  ;;                  (regexp . "\\(\\s-+\\)\\(->\\|→\\)\\s-+")
  ;;                  (modes . '(haskell-mode literate-haskell-mode))))
  ;;   (add-to-list 'align-rules-list
  ;;                '(haskell-left-arrows
  ;;                  (regexp . "\\(\\s-+\\)\\(<-\\|←\\)\\s-+")
  ;;                  (modes . '(haskell-mode literate-haskell-mode)))))


#+END_SRC
***** Force haskell-mode on cabal-mode
#+BEGIN_SRC emacs-lisp
 ; (add-hook 'haskell-cabal-mode-hook (require 'haskell-mode))
#+END_SRC
***** Remove overlays from ghc-check.el because flycheck is enabled
#+BEGIN_SRC emacs-lisp
  ;(set-face-attribute 'ghc-face-error nil :underline nil)
  ;(set-face-attribute 'ghc-face-warn nil :underline nil)
#+END_SRC
***** Indentation
     #+BEGIN_SRC emacs-lisp
       ; haskell-mode indentation is incompatible with structured-haskell-mode
       ; (add-hook 'haskell-mode-hook 'turn-on-haskell-indentation)
     #+END_SRC
**** (C-c C-c) haskell-compile
     #+BEGIN_SRC emacs-lisp
       ;; (eval-after-load "haskell-mode"
       ;;     '(define-key haskell-mode-map (kbd "C-c C-c") 'haskell-compile))

       ;; (eval-after-load "haskell-cabal"
       ;;     '(define-key haskell-cabal-mode-map (kbd "C-c C-c") 'haskell-compile))
     #+END_SRC
**** haskell-interactive-mode
    #+BEGIN_SRC emacs-lisp
      ;; (add-hook 'haskell-mode-hook 'interactive-haskell-mode)
      ;; (define-key haskell-mode-map (kbd "C-c C-l") 'haskell-process-load-or-reload)
      ;; (define-key haskell-mode-map (kbd "C-`") 'haskell-interactive-bring)
      ;; (define-key haskell-mode-map (kbd "C-c C-t") 'haskell-process-do-type)
      ;; (define-key haskell-mode-map (kbd "C-c C-i") 'haskell-process-do-info)
      ;; (define-key haskell-mode-map (kbd "C-c C-c") 'haskell-process-cabal-build)
      ;; (define-key haskell-mode-map (kbd "C-c C-k") 'haskell-interactive-mode-clear)
      ;; (define-key haskell-mode-map (kbd "C-c c") 'haskell-process-cabal)
      ;; (define-key haskell-mode-map (kbd "SPC") 'haskell-mode-contextual-space)
      ; cabal-mode
      ;; (define-key haskell-cabal-mode-map (kbd "C-`") 'haskell-interactive-bring)
      ;; (define-key haskell-cabal-mode-map (kbd "C-c C-k") 'haskell-interactive-mode-clear)
      ;; (define-key haskell-cabal-mode-map (kbd "C-c C-c") 'haskell-process-cabal-build)
      ;; (define-key haskell-cabal-mode-map (kbd "C-c c") 'haskell-process-cabal)
    #+END_SRC
** JavaScript
*** web-mode
**** Force *jsx* mode for all .jsx? files
     This gives us JSX highlighting
      #+BEGIN_SRC emacs-lisp
        (setq web-mode-content-types-alist
              '(("jsx" . "\\.js[x]?\\'")))
      #+END_SRC
*** js2-mode
   #+BEGIN_SRC emacs-lisp
     ;; adjust indents for web-mode to 2 spaces
     (defun my-web-mode-hook ()
       "Hooks for Web mode. Adjust indents"
         ;;; http://web-mode.org/
       (setq web-mode-markup-indent-offset 2)
       (setq web-mode-css-indent-offset 2)
       (setq web-mode-code-indent-offset 2)
       (setq web-mode-attr-indent-offset 2)
       (add-hook 'local-write-file-hooks
                 (lambda ()
                   (delete-trailing-whitespace)
                                  nil)))
     (add-hook 'web-mode-hook  'my-web-mode-hook)
   #+END_SRC
*** js3-mode
#+BEGIN_SRC emacs-lisp
  '(js3-auto-indent-p t)
  '(js3-consistent-level-indent-inner-bracket t)
  '(js3-curly-indent-offset 2)
  '(js3-enter-indents-newline t)
  '(js3-expr-indent-offset 2)
  '(js3-indent-level 0)
  '(js3-indent-on-enter-key t)
  '(js3-lazy-commas t)
  '(js3-paren-indent-offset 2)
  '(js3-square-indent-offset 2)
#+END_SRC
*** prettier-js
#+BEGIN_SRC emacs-lisp
  (require 'prettier-js)
  (add-hook 'web-mode-hook 'prettier-js-mode)
  ;; (defun enable-minor-mode (my-pair)
  ;;   "Enable minor mode if filename match the regexp.  MY-PAIR is a cons cell (regexp . minor-mode)."
  ;;   (if (buffer-file-name)
  ;;       (if (string-match (car my-pair) buffer-file-name)
  ;;           (funcall (cdr my-pair)))))
  ;; (add-hook 'web-mode-hook #'(lambda ()
  ;;                             (enable-minor-mode
  ;;                              '("\\.jsx?\\'" . prettier-js-mode))))
#+END_SRC
** TypeScript
   #+BEGIN_SRC emacs-lisp
     (defun setup-tide-mode ()
       (interactive)
       (tide-setup)
       (flycheck-mode +1)
       (setq flycheck-check-syntax-automatically '(save mode-enabled))
       (eldoc-mode +1)
       (tide-hl-identifier-mode +1)
       ;; company is an optional dependency. You have to
       ;; install it separately via package-install
       ;; `M-x package-install [ret] company`
       (company-mode +1))

     ;; formats the buffer before saving
     (add-hook 'before-save-hook 'tide-format-before-save)

     (add-hook 'typescript-mode-hook #'setup-tide-mode)

     ;; format options
     (setq tide-format-options '(:indentSize 2 :tabSize 2 :placeOpenBraceOnNewLineForControlBlocks nil))

     (add-hook 'web-mode-hook
               (lambda ()
                 (when (string-equal "tsx" (file-name-extension buffer-file-name))
                   (setup-tide-mode))))
   #+END_SRC
** Lisp
*** Slime
#+BEGIN_SRC emacs-lisp
  (setq slime-contribs '(slime-fancy
                         slime-indentation
                         slime-sbcl-exts
                         slime-scratch)
        inferior-lisp-program "sbcl")
#+END_SRC
*** Paredit
  #+BEGIN_SRC emacs-lisp
    (autoload 'enable-paredit-mode "paredit" "Turn on pseudo-structural editing of Lisp code." t)
    (add-hook 'emacs-lisp-mode-hook       #'enable-paredit-mode)
    (add-hook 'eval-expression-minibuffer-setup-hook #'enable-paredit-mode)
    (add-hook 'ielm-mode-hook             #'enable-paredit-mode)
    (add-hook 'lisp-mode-hook             #'enable-paredit-mode)
    (add-hook 'lisp-interaction-mode-hook #'enable-paredit-mode)
    (add-hook 'scheme-mode-hook           #'enable-paredit-mode)
    (add-hook 'clojure-mode-hook 'paredit-mode)
  #+END_SRC
** SQL
#+BEGIN_SRC emacs-lisp
  (when (require 'sql-upcase nil :noerror)
     (add-hook 'sql-mode-hook 'sql-upcase-mode)
     (add-hook 'sql-interactive-mode-hook 'sql-upcase-mode))
#+END_SRC
* Custom Code
* File Associations
  #+BEGIN_SRC emacs-lisp
    (add-to-list 'auto-mode-alist '("Dockerfile" . shell-script-mode))
    (add-to-list 'auto-mode-alist '("\\.md$" . markdown-mode))
    (add-to-list 'auto-mode-alist '("\\.post$" . markdown-mode))
    (add-to-list 'auto-mode-alist '("emacs" . lisp-mode))
    (add-to-list 'auto-mode-alist '("zshrc" . shell-script-mode))
    (add-to-list 'auto-mode-alist '("\\.purs$" . purescript-mode))
    (add-to-list 'auto-mode-alist '("\\.org$" . org-mode))
    (add-to-list 'auto-mode-alist '("\\.scss$" . sass-mode))
    (add-to-list 'auto-mode-alist '("\\.rc$" . restclient-mode))
    (add-to-list 'auto-mode-alist '("\\.json$" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.jsx?$" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.php?$" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.css?$" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.tsx\\'" . web-mode))
    ; custom rc files for JS projects
    (add-to-list 'auto-mode-alist '("\\.faterc$" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.leorc$" . web-mode))
  #+END_SRC
* UI
This is setting up the UI as a like it, simple and clean. I also put
some tweak affecting navigation in this section (e.g. switching
between windows)
** Navigation
- Swap buffer around with C-Shift-<key>
  #+BEGIN_SRC emacs-lisp
    (use-package buffer-move
      :bind (("C-S-<up>" . buf-move-up)
             ("C-S-<down>" . buf-move-down)
             ("C-S-<left>" . buf-move-left)
             ("C-S-<right>" . buf-move-right)))
  #+END_SRC
- [[https://www.emacswiki.org/emacs/WinnerMode][Winner mode]] allow us to jump between window configuration using =C-c
  <left>= and =C-c <right>=. Very useful when wanting to see one
  buffer with more space then be back to comparison for instance
    #+BEGIN_SRC emacs-lisp
      (when (fboundp 'winner-mode)
        (winner-mode 1))
    #+END_SRC
- Use [[https://github.com/justbur/emacs-which-key][which-key]] to help us figure out what we can do next
#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :defer 5
    :diminish which-key-mode
    :init
    (setq which-key-sort-order 'which-key-key-order-alpha)
    :bind* (("M-m ?" . which-key-show-top-level))
    :config
    (which-key-mode)
    (which-key-add-key-based-replacements
      "M-m ?" "top level bindings"))
#+END_SRC
- Unbind =C-z=, I don't want my GUI emacs to disappear on me
  #+BEGIN_SRC emacs-lisp
    (global-unset-key (kbd "C-z"))
  #+END_SRC
- Enable [[https://github.com/Fuco1/smartparens][smartparens]] to automatically have our pairs matched for us
  #+BEGIN_SRC emacs-lisp
    (use-package smartparens-config
      :ensure smartparens
      :config
      (progn
        (show-smartparens-global-mode t)))

    (add-hook 'prog-mode-hook 'turn-on-smartparens-strict-mode)
  #+END_SRC
** Prettier mode-line
We use the cyan [[https://github.com/kuanyui/moe-theme.el][moe-theme]] for our powerline.
#+BEGIN_SRC emacs-lisp
  (use-package powerline
    :config
    (use-package moe-theme
      :commands (powerline-moe-theme moe-theme-set-color))
    (powerline-moe-theme)
    (moe-theme-set-color 'cyan))
#+END_SRC
*** TODO We wanna switch to the more powerful [[https://github.com/TheBB/spaceline][spaceline]] eventually and [[https://github.com/domtronn/spaceline-all-the-icons.el][spaceline-all-the-icons]]
** Mode-line customization
- Better unique filename. We want to see =file|file= and =file|titi=
  when opening =/toto/file= and =/titi/file= instead of =file<x>=.
  #+BEGIN_SRC emacs-lisp
    (use-package uniquify
      :ensure nil ;; this is a builtin package
      :config
      (setq uniquify-buffer-name-style 'post-forward))
  #+END_SRC
** Highlight or Fix some common mistakes
- Trailing whitespaces
  #+BEGIN_SRC emacs-lisp
    (add-hook 'prog-mode-hook (lambda () (interactive) (setq show-trailing-whitespace 1)))
  #+END_SRC
- 80 columns rule using [[https://www.emacswiki.org/emacs/FillColumnIndicator][fill-column-indicator]]
  #+BEGIN_SRC emacs-lisp
    (use-package fill-column-indicator
      :commands (fci-mode)
      :init
      (setq fci-rule-width          3
            fci-rule-column         79
            fci-rule-use-dashes     t
            fci-rule-color          "plum")
      (define-globalized-minor-mode global-fci-mode fci-mode (lambda ()
                                                               (if buffer-file-name (fci-mode 1)
                                                                 (fci-mode 0))))
      (global-fci-mode 1))
  #+END_SRC
- At 100 columns, use [[https://github.com/jordonbiondo/column-enforce-mode][column-enforce-mode]] instead. We set the color of
  faulty characters to "violet red"
  #+BEGIN_SRC emacs-lisp
    (use-package column-enforce-mode
      :commands (column-enforce-mode)
      :config
      (setq column-enforce-column 100)
      (custom-set-faces
            `(column-enforce-face ((t (:inherit font-lock-warning-face :underline t :foreground "violet red"))))))
  #+END_SRC
- Always add a newline at end of files, and default tab to 4 spaces
  #+BEGIN_SRC emacs-lisp
    (setq mode-require-final-newline t
          tab-width 4)
  #+END_SRC
** I like my theme dark
#+BEGIN_SRC emacs-lisp
  (custom-set-faces
   '(default ((t (:inherit nil
                           :stipple nil
                           :background "#2e3436"
                           :foreground "#eeeeec"
                           :inverse-video nil
                           :box nil
                           :strike-through nil
                           :overline nil
                           :underline nil
                           :slant normal
                           :weight normal
                           :height 70
                           :width normal
                           :foundry "unknown"
                           :family "DejaVu Sans Mono"))))
   '(hl-line ((t (:background "steel blue"))))
   '(idle-highlight ((t (:inherit region :background "tomato")))))
#+END_SRC
* Encoding System
UTF-8 for all the things!
#+BEGIN_SRC emacs-lisp
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (set-language-environment "UTF-8")
  (prefer-coding-system 'utf-8)
  (setq-default buffer-file-coding-system 'utf-8-auto-unix)
#+END_SRC
* Backup
By default emacs backups edited buffer in their current
directory. Having a bunch of =~= files everywhere in my filesystem is
highly annoying, so let's put them somewhere else.
#+BEGIN_SRC emacs-lisp
  (let ((backups-dir (expand-file-name "backups" user-emacs-directory)))
    (setq backup-by-copying t                             ;; Copy the file, don't rename it
          backup-directory-alist `((".*" . ,backups-dir)) ;; Put them in ~/.emacs.backups
          delete-old-versions t                           ;; Delete old version
          kept-old-versions 3                             ;; Keep the 3 oldest version
          kept-new-versions 3                             ;; and the 3 newest one (including the one being made)
          version-control t))                             ;; Use numbered file name
#+END_SRC
* Undo Tree
[[https://www.emacswiki.org/emacs/UndoTree][undo-tree]] provide a visual tree of the undo that we have made.
#+BEGIN_SRC emacs-lisp
  (use-package undo-tree
    :bind (("<f7>" . undo-tree-visualize))
    :config
    (setq undo-tree-auto-save-history t)
    (let ((undo-dir (expand-file-name "undo" user-emacs-directory)))
      (setq undo-tree-history-directory-alist `((".*" . ,undo-dir))))
    (global-undo-tree-mode))
#+END_SRC
* Helm
Helm make it easy to filter stuff :). I used [[http://tuhdo.github.io/helm-intro.html][this tutorial]] as an
inspiration for most of the following configuration.
We bind the following global keys:
  - =C-c h= :: is made the helm prefix, which-key will show possible
               match if we ever forget what to do next
  - =M-x= :: helm-M-x, same but better
  - =M-y= :: helm-show-kill-ring, allows to have a visual view of the
             kill ring
  - =C-x b= :: helm-mini, allows switch buffer using helm powerful
               matching
  - =C-x C-f= :: helm-find-files, find-file but better ;-).
  - =C-c h o=  :: helm-occur, allows quickly finding occurrences of
                  pattern in current buffer
In helm mode, we define the following to bindings:
  - =<TAB>= :: helm-execute-persistent-action, will usually show the
               current match content or if in something like =M-x= the
               associated help
  - =C-z= :: helm-select-action, will show available action from the
             current helm status
We let helm auto-resize from =30%= to =70%= of the frame is
affecting. We also set it to use the current frame instead of opening
a whole window for itself.
#+BEGIN_SRC emacs-lisp
  (use-package helm
    :bind (("M-x"         . helm-M-x)
           ("M-y"         . helm-show-kill-ring)
           ("C-x b"       . helm-mini)
           ("C-x C-f"     . helm-find-files)
           ("C-c h o"     . helm-occur))
    :config
    (require 'helm-config)
    (global-unset-key (kbd "C-x c"))
    (global-set-key (kbd "C-c h")         'helm-command-prefix)
    (define-key helm-map (kbd "<tab>")    'helm-execute-persistent-action)
    (define-key helm-map (kbd "C-z")      'helm-select-action)
    (helm-mode t)
    (setq helm-autoresize-max-height 70
          helm-autoresize-min-height 30
          helm-split-window-in-side-p t)
    (helm-autoresize-mode t))
#+END_SRC
* Flyspell
Let's have some warning when we type things wrong ate
#+BEGIN_SRC emacs-lisp
  (use-package flyspell-mode
    :ensure nil
    :config
    (add-hook 'flyspell-mode-hook 'flyspell-buffer)
    (setq flyspell-issue-message-flag nil)
    (dolist (hook '(text-mode-hook org-mode-hook))
      (add-hook hook (lambda () (flyspell-mode 1))))
    (dolist (hook '(change-log-mode-hook log-edit-mode-hook))
      (add-hook hook (lambda () (flyspell-mode -1)))))
#+END_SRC
* Flycheck
We want to check for linter errors as we go (see [[https://github.com/flycheck/flycheck][here]] for
documentation)
#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :ensure t
    :init (global-flycheck-mode))
#+END_SRC
* Company
We use the [[http://company-mode.github.io/][company-mode]] completion framework
#+BEGIN_SRC emacs-lisp
  (use-package company)
#+END_SRC
* Golang
  - Install go-mode and set it up to use =goimports= to format our
    files. go-mode depends on the following tools:
    - [[github.com/rogpeppe/godef][godef]]
    - [[golang.org/x/tools/cmd/goimports][goimports]]
    - [[golang.org/x/tools/cmd/godoc][godoc]]
    #+BEGIN_SRC emacs-lisp
      (use-package go-mode
        :commands (gofmt-before-save)
        :config
        (setq gofmt-command "goimports")
        (add-hook 'before-save-hook   'gofmt-before-save)
        (add-hook 'go-mode-hook       'column-enforce-mode)
        (add-hook 'go-mode-hook       (lambda () (flyspell-prog-mode)))
        (add-hook 'go-mode-hook       (lambda ()
                                        (local-set-key (kbd "C-c C-r") 'go-remove-unused-imports)))
        (add-hook 'go-mode-hook       (lambda ()
                                        (local-set-key (kbd "M-.") 'godef-jump)))
        (define-key go-mode-map (kbd "C-c C-c")       'comment-region)
        (define-key go-mode-map (kbd "C-u C-c C-c")   'uncomment-region))
    #+END_SRC
  - Install [[https://github.com/syohex/emacs-go-eldoc][go-eldoc]] to see variable, return value and function
    argument in the echo area. It depends on [[github.com/nsf/gocode][gocode]].
    #+BEGIN_SRC emacs-lisp
      (use-package go-eldoc
        :after go-mode
        :config
        (add-hook 'go-mode-hook 'go-eldoc-setup))
    #+END_SRC
  - Activate completion with [[https://github.com/nsf/gocode/tree/master/emacs-company][company-go]]
    #+BEGIN_SRC emacs-lisp
      (use-package company-go
        :after company
        :config
        (setq company-idle-delay .1
              company-echo-delay 0)
        (add-hook 'go-mode-hook (lambda ()
                                  (set (make-local-variable 'company-backends) '(company-go))
                                  (company-mode)))
        (custom-set-faces
         `(company-scrollbar-bg       ((t (:background "lightgray"))))
         `(company-scrollbar-fg       ((t (:background "darkgrey"))))
         '(company-preview            ((t (:foreground "darkgray" :underline t))))
         '(company-preview-common     ((t (:inherit company-preview))))
         '(company-tooltip            ((t (:background "lightgray" :foreground "black"))))
         '(company-tooltip-selection  ((t (:background "steelblue" :foreground "white"))))
         '(company-tooltip-common     ((((type x)) (:inherit company-tooltip :weight bold))
                                       (t (:inherit company-tooltip))))
         '(company-tooltip-common-selection
           ((((type x)) (:inherit company-tooltip-selection :weight bold))
            (t (:inherit company-tooltip-selection))))))
    #+END_SRC
  - Use go-guru, it depends on the [[https://godoc.org/golang.org/x/tools/cmd/guru][guru]] tool.
    #+BEGIN_SRC emacs-lisp
      (use-package go-guru
        :after go-mode
        :commands (go-guru-hl-identifier-mode)
        :config
        (define-key go-mode-map (kbd "C-c g") 'go-guru-map)
        (add-hook 'go-mode-hook 'go-guru-hl-identifier-mode))
    #+END_SRC
  - Make use of [[https://github.com/emacsmirror/godoctor][godoctor.el]], it depends on the [[http://gorefactor.org/][godocotor]] utility
    #+BEGIN_SRC emacs-lisp
      (use-package godoctor
        :bind (("C-c d r" . godoctor-rename)
               ("C-c d e" . godoctor-extract)
               ("C-c d t" . godoctor-toggle)
               ("C-c d g" . godoctor-godoc)))
    #+END_SRC
* Direnv
I make use of several different gopath, this makes use of the [[https://direnv.net/][direnv]]
tool to automatically update the environment of the current buffer
#+BEGIN_SRC emacs-lisp
  (use-package direnv
    :config
    (direnv-mode))
#+END_SRC

* TODO ivy (ivy-smex vs counsel-M-x) counsel swiper (vs helm)
